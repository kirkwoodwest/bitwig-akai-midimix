package com.kirkwoodwest.openwoods.osc;

import com.bitwig.extension.api.opensoundcontrol.OscAddressSpace;
import com.bitwig.extension.api.opensoundcontrol.OscMethodCallback;
import com.bitwig.extension.api.opensoundcontrol.OscModule;
import com.bitwig.extension.controller.api.*;
import com.kirkwoodwest.openwoods.settings.NumberSetting;
import com.kirkwoodwest.openwoods.settings.SettingsHelper;

import java.io.Flushable;
import java.util.ArrayList;
import java.util.List;

public class OscHost implements Flushable {
  private final SettableEnumValue settingEnabled;
  private final SettableStringValue settingStatusIn;
  private final SettableStringValue settingStatusOut;
  private final SettableStringValue settingOutAddress;
  private final NumberSetting settingOutPort;
  private final NumberSetting settingInPort;
  private final Signal settingRestart;
  private final SettableStringValue settingDebugFilter;
  
  private String OSC_MESSAGE_START = "/osc/start";
  private String OSC_MESSAGE_END = "/osc/end";
  private String statusLocal = "Disconnected";

  //Osc Host
  private final ControllerHost host;
  private OpenSoundControlServer oscServer;
  private OpenSoundControlClient oscClient;
  private OscModule oscModule;
  private OscAddressSpace addressSpace;
  private final SettableBooleanValue settingDebug;

  //Message Queue
  private List<OscMessageData> messages = new ArrayList<>();

  //Osc Path for messages generated by this host
  private final String oscPath;
  private boolean enabled = true;

  public OscHost(ControllerHost host, String oscPath) {
    this.host = host;
    this.oscPath = oscPath;

    OSC_MESSAGE_START = oscPath + OSC_MESSAGE_START;
    OSC_MESSAGE_END = oscPath + OSC_MESSAGE_END;

    //Configure Panel
    //Enabled Setting Enum Value
    settingEnabled = host.getPreferences().getEnumSetting("Enabled", "Osc", new String[]{"ON", "OFF"}, "ON");
    settingEnabled.markInterested();
    enabled = settingEnabled.get().equals("ON");

    //Restart Extension
    settingRestart = host.getPreferences().getSignalSetting("Requires restart after any changes to OSC Settings", "Osc", "Restart Extension");
    ;
    settingRestart.addSignalObserver(host::restart);

    //Status
    settingStatusIn = host.getPreferences().getStringSetting("Status In", "Status", 20, "Not Connected");
    settingStatusIn.markInterested();
    settingStatusOut = host.getPreferences().getStringSetting("Status Out", "Status", 20, "Not Connected");
    settingStatusOut.markInterested();

    //In Port
    settingInPort = new NumberSetting(host.getPreferences(), "Port In", "Osc In", 8000, 12000, 1, "", Constants.PORT_IN_DEFAULT);
    settingInPort.markInterested();

    //Address
    settingOutAddress = host.getPreferences().getStringSetting("Address Out", "Osc Out", 20, Constants.ADDRESS_DEFAULT);
    settingOutAddress.markInterested();

    //Out Port
    settingOutPort = new NumberSetting(host.getPreferences(), "Port Out", "Osc Out", 8000, 12000, 1, "", Constants.PORT_OUT_DEFAULT);
    settingOutPort.markInterested();

    //Debug Mode
    settingDebug = host.getPreferences().getBooleanSetting("Debug OSC Events To Console", "Debug", false);
    settingDebug.markInterested();

    settingDebugFilter = host.getPreferences().getStringSetting("Debug Filter", "Debug", 64, "");
    settingDebugFilter.markInterested();

    doConnections();
  }

  private void doConnections() {
    if (enabled) {
      try {
        oscModule = host.getOscModule();
        addressSpace = oscModule.createAddressSpace();
        oscServer = new OpenSoundControlServer(host, oscModule, addressSpace, settingInPort.get(), oscPath);
        oscClient = new OpenSoundControlClient(host, oscModule, addressSpace, settingOutAddress.get(), settingOutPort.get(), oscPath);
      
      } catch (Exception e) {
        oscModule = null;
        statusLocal = "OSC Module Not Available";
        return;
      }

      if (settingInPort.get() != settingOutPort.get() && oscModule != null) {
        settingDebug.addValueObserver((v) -> {
          oscClient.setDebugEnabled(v);
          oscServer.setDebugEnabled(v);
        });

        settingDebugFilter.addValueObserver(oscClient::setDebugFilter);
      } else {
        oscServer = null;
        oscClient = null;
        statusLocal = "Ports and Out must be different";
      }
    } else {
      oscServer = null;
      oscClient = null;
      statusLocal = "DISABLED";
    }

    host.scheduleTask(this::updateStatus, 100);
  }

  private void updateStatus() {
    if (oscServer == null || oscClient == null) {
      settingStatusIn.set(statusLocal);
      settingStatusOut.set(statusLocal);
    } else {
      settingStatusIn.set(oscServer.getStatus());
      settingStatusOut.set(oscClient.getStatus());
    }

    SettingsHelper.setEnabled(settingStatusIn, enabled);
    SettingsHelper.setEnabled(settingStatusIn, enabled);
    SettingsHelper.setEnabled(settingStatusOut, enabled);
    SettingsHelper.setEnabled(settingInPort.getSetting(), enabled);
    SettingsHelper.setEnabled(settingOutAddress, enabled);
    SettingsHelper.setEnabled(settingOutPort.getSetting(), enabled);
    SettingsHelper.setEnabled((Setting) settingDebug, enabled);
  }

  //----------------------------------------------------------------------------------
  //OSC Callbacks

  //Register Osc Callback Simple
  public void registerOscCallback(String target, String description, OscMethodCallback callback) {
    if (oscServer == null) {
      if (settingDebug.get()) {
        host.println("NULL Server Cannot Register Callback: " + target + " " + description);
      }
      return;
    }
    if (settingDebug.get()) {
      System.out.println("Registering OSC Callback: " + target + " " + description);
    }
    oscServer.registerOscCallback(target, description, callback);
  }

  //Register Osc Callback with Type Tag Pattern
  public void registerOscCallback(String target, String typeTagPattern, String description, OscMethodCallback callback) {
    if (oscServer == null) {
      if (settingDebug.get()) {
        host.println("NULL Server Cannot Register Callback: " + target + " " + description);
      }
      return;
    }
    if (settingDebug.get()) {
      host.println("Registering OSC Callback: " + target + " " + typeTagPattern + " " + description);
    }
    oscServer.registerOscCallback(target, typeTagPattern, description, callback);
  }

  //Default Callback
  public void registerDefaultCallback(OscMethodCallback callback) {
    if (oscServer == null) {
      if (settingDebug.get()) {
        host.println("NULL Server Cannot Register Default Callback:");
      }
      return;
    }
    if (settingDebug.get()) {
      host.println("Registering Default OSC Callback");
    }
    oscServer.registerDefaultCallback(callback);
  }

  //----------------------------------------------------------------------------------
  //OSC Send

  //Send OSC Message
  synchronized public void addMessageToQueue(String target, Object... message) {
    if (!this.enabled) return;
    messages.add(new OscMessageData(target, message));
  }

  public void sendMessage(String target, Object... message) {
    if (!this.enabled || oscClient == null) return;
    oscClient.send(target, message);
  }

  public void sendQueue() {
    if (!this.enabled || messages.isEmpty() || oscClient == null) {
      if (!messages.isEmpty()) messages.clear(); //Clear messages if they exist...
      return; // Early return if disabled or no targets
    }
    synchronized (messages) {
      oscClient.send(OSC_MESSAGE_START, true);
      messages.forEach((message) -> {
        String target = message.address();
        Object[] data = message.data();
        oscClient.send(target, data);
      });
      oscClient.send(OSC_MESSAGE_END, true);
      messages.clear();
    }
  }

  @Override
  public void flush() {
    sendQueue();
  }

  public void printDocumentation() {

  }
}
